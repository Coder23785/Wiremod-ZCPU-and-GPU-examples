// ----------------------------------------------
// It's a little messy...
// Sorry about that...
// YouTube: https://youtu.be/AjvIafEOOW0
//----------------------------------------------


mov #regHWClear,0; //Stop hardware clearing 
DENTRYPOINT 0, DRAW_RENDER
DENTRYPOINT 4, ASYNC_RENDER
mov #regAsyncClk,1; //Start async
mov #regAsyncFreq,500000;

 
DRAW_RENDER:
DEXIT 
ASYNC:
ASYNC_RENDER:
DCLRSCR GCOL_BACKGROUND
ASYNC_LOOP:
//ADD [DBGPRINTMEMORYOFFSET], 6
DBEGIN
CALL GRAPHICSDEBUG
DEND // IS ALREADY IN GFX_DRAWCHARMATRIX
JMP ASYNC_LOOP


//SOME BASIC COLORS
GCOL_RED:   DB 255,0,0,255
GCOL_GREEN: DB 0,255,0,255
GCOL_BLUE:  DB 0,0,255,255
GCOL_BLACK: DB 0,0,0,255
GCOL_WHITE: DB 255,255,255,255
GCOL_GREY:  DB 127,127,127,255
GCOL_BACKGROUND: DB 0,0,0,150
GCOL_BLACKFADED: DB 0,0,0,175
GCOL_WHITEFADED: DB 255,255,255,50
GCOL_BLUEFADED:  DB 0,0,255,150


//-------------------------------------------////-------------------------------------------////-------------------------------------------//
//-------------------------------------------//
//-------------------------------------------//
//-------------------------------------------////-------------------------------------------////-------------------------------------------//
//GRAPHICSDEBUG
//Its a debugging window, not much else
GRAPHICSDATA00: DB 0,0  //GRAPHICSDATAXX - they are mainly used for holding coords
GRAPHICSDATA01: DB 0,0  //that are required by the draw instructions.
GRAPHICSDATA02: DB 0,0
GRAPHICSDATA03: DB 0,0
GRAPHICSDATA04: DB 0,0
DEBUGWNDCOORDS: DB 0,0,0,0 // This vector here holds the origin of the squares drawn around the 
                       // generic memory viewer at the bottom of the screen. 
                       // SIDENOTE: This doesn't determine the location of the squares. It's
                       // only used for placeing certain text and redrawing the squares. 
DBGREGTEXT00: DB "EAX: ",0
DBGREGTEXT01: DB "EBX: ",0
DBGREGTEXT02: DB "ECX: ",0
DBGREGTEXT03: DB "EDX: ",0
DBGREGTEXT04: DB "ESI: ",0
DBGREGTEXT05: DB "EDI: ",0
DBGREGTEXT06: DB "ESP: ",0
DBGREGTEXT07: DB "EBP: ",0
DBGREGTEXT08: DB "R0: ",0
DBGREGTEXT09: DB "R1: ",0
DBGREGTEXT10: DB "R2: ",0
DBGREGTEXT11: DB "R3: ",0
DBGREGTEXT12: DB "R4: ",0
DBGREGTEXT13: DB "R5: ",0
DBGREGTEXT14: DB "R6: ",0
DBGREGTEXT15: DB "R7: ",0
DBGREGTEXT16: DB "R8: ",0
DBGREGTEXT17: DB "R9: ",0
DBGREGTEXT18: DB "R10: ",0
DBGREGTEXT19: DB "R11: ",0
DBGREGTEXT20: DB "R12: ",0
DBGREGTEXT21: DB "R13: ",0
DBGREGTEXT22: DB "R14: ",0
DBGREGTEXT23: DB "R15: ",0
DBGPROCIDTEXT: DB "PROCEDURE: ",0
DBGAUTOIDTEXT: DB "DEBUG ID: NOT IMPLEMENTED ",0
DBGTITLE: DB "DEBUGGER",0
DBGNUMBERS: ALLOC 24 //HOLDS REGISTER VALUES FOR PRINTING
DBGPROCID: DB 0 //MANUAL IDS THAT ARE ASSIGNED BEFORE GRAPHICSDEBUG IS CALLED
DBGAUTOID: DB 0 //ID THAT THE DEBUG FUNCTION GENERATES ITSELF EVERYTIME IT'S CALLED

DBGTEXTTABLE:
DB DBGREGTEXT00,DBGREGTEXT01,DBGREGTEXT02,DBGREGTEXT03,DBGREGTEXT04,DBGREGTEXT05,DBGREGTEXT06,DBGREGTEXT07
DB DBGREGTEXT08,DBGREGTEXT09,DBGREGTEXT10,DBGREGTEXT11,DBGREGTEXT12,DBGREGTEXT13,DBGREGTEXT14,DBGREGTEXT15
DB DBGREGTEXT16,DBGREGTEXT17,DBGREGTEXT18,DBGREGTEXT19,DBGREGTEXT20,DBGREGTEXT21,DBGREGTEXT22,DBGREGTEXT23
DB DBGPROCIDTEXT,DBGAUTOIDTEXT

DBGTEXTVERTICALSPACE: DB 10

DBGPRINTMEMORYOFFSET: DB 0 //OFFSET FOR MEMORY VIEWER
///DBGPRINTMEMORYHORIZONTALSPACE: DB 0 //SPACING BETWEEN COLUMNS (NOT NEEDED)
DBGPRINTMEMORYCOLUMNS: DB "|---------------|",0 //DEFINES COLUMN SPACING
DBGPRINTMEMORYTITLE: DB "MEMORY OFFSET: ",0

DBGPRINTCOLON: DB ": ",0
DBGADDRMAXDIGITS:   DB "1000000000",0 //USED TO GET THE WIDTH IN CHARACTERS OF THE ADDRESS VALUES ON THE MEMORY VIEWER
DBGNUMMAXDIGITS:    DB "10000000 ",0 //USED TO SET COLUMN SPACING  
DBGADDRMAXDIGITSNUM: DB 1000000000 //THE # USED FOR PRINTING ADDRESSES
DBGVALUESPERROW: DB 6
DBGVALUESPERCOLUMN: DB 20

GRAPHICSDEBUG:
//---------------------------------- DRAW DEBUG WINDOW
PUSHA //REGISTERS NEED TO BE UNMODIFIED IF THEY ARE GOING TO BE PRINTED ON SCREEN

MOV EAX, [DBGAUTOID] //MAKE A NEW ID
INC EAX
MOV [DBGAUTOID], EAX

MOV EAX, GRAPHICSDATA00
MOV [EAX], 512
MOV [EAX+1], 512
MOV EAX, GRAPHICSDATA01
MOV [EAX], 0
MOV [EAX+1], 0
DCOLOR GCOL_BLUE
DRECTWH GRAPHICSDATA01, GRAPHICSDATA00
POPA
GRAPHICSDEBUG_0001://MOVES THE REGISTER VALUES INTO "DBGNUMBERS" FOR PRINTING\
MOV [DBGNUMBERS+0],EAX
MOV [DBGNUMBERS+1],EBX
MOV [DBGNUMBERS+2],ECX
MOV [DBGNUMBERS+3],EDX
MOV [DBGNUMBERS+4],ESI
MOV [DBGNUMBERS+5],EDI
MOV [DBGNUMBERS+6],ESP
MOV [DBGNUMBERS+7],EBP
MOV [DBGNUMBERS+08],R0
MOV [DBGNUMBERS+09],R1
MOV [DBGNUMBERS+10],R2
MOV [DBGNUMBERS+11],R3
MOV [DBGNUMBERS+12],R4
MOV [DBGNUMBERS+13],R5
MOV [DBGNUMBERS+14],R6
MOV [DBGNUMBERS+15],R7
MOV [DBGNUMBERS+16],R8
MOV [DBGNUMBERS+17],R9
MOV [DBGNUMBERS+18],R10
MOV [DBGNUMBERS+19],R11
MOV [DBGNUMBERS+20],R12
MOV [DBGNUMBERS+21],R13
MOV [DBGNUMBERS+22],R14
MOV [DBGNUMBERS+23],R15
GRAPHICSDEBUG_PRINTREGISTERS: //PREPARE TO PRINT
PUSHA
DCOLOR GCOL_WHITE
MOV EAX, DBGNUMBERS //ARRAY OF REGISTER VALUES
MOV EBX, DBGTEXTTABLE //TABLE OF STRINGS FOR PRINTING
XOR ECX, ECX //COUNTER
MOV [GRAPHICSDATA00],   0 //START AT TOP LEFT
MOV [GRAPHICSDATA00+1], 0
GRAPHICSDEBUG_PRINTREGISTERS_0://THE LOOP THAT ACTUALLY PRINTS THE REGISTERS
DWRITE GRAPHICSDATA00, [EBX]
DTEXTWIDTH EDX, [EBX] //GET THE WIDTH OF THE CURRENT STRING
ADD [GRAPHICSDATA00], EDX //OFFSET X FOR PRINTING REGISTER VALUES
DWRITEI GRAPHICSDATA00, [EAX]
ADD [GRAPHICSDATA00+1], [DBGTEXTVERTICALSPACE] //NEWLINE
XOR EDX, EDX
MOV [GRAPHICSDATA00], EDX //RESET X FOR NEXT ITERATION
INC EBX //UPDATE STRING POINTER
INC ECX //UPDATE COUNTER
INC EAX //UPDATE REGISTER VALUE POINTER
CMP ECX, 26
JNGE GRAPHICSDEBUG_PRINTREGISTERS_0
GRAPHICSDEBUG_PRINTMEMORY: //PREPARE TO PRINT MEMORY
MOV EAX, [DBGPRINTMEMORYOFFSET]
ADD [GRAPHICSDATA00+1], [DBGTEXTVERTICALSPACE] //GOTO A NEWLINE
DTEXTWIDTH EBX, DBGPRINTMEMORYCOLUMNS //EBX = LENGTH OF COLUMN
DWRITE GRAPHICSDATA00, DBGPRINTMEMORYTITLE //PRINT "MEMORY OFFSET: "
DTEXTWIDTH ECX, DBGPRINTMEMORYTITLE
ADD [GRAPHICSDATA00], ECX //MOV COORDS OVER TO PRINT MEMORY OFFSET
DWRITEI GRAPHICSDATA00, [DBGPRINTMEMORYOFFSET] //PRINT MEMORY OFFSET NEXT TO "MEMORY OFFSET: "
MOV [GRAPHICSDATA00], 0 //RESET HORIZONTAL OFFSET
ADD [GRAPHICSDATA00+1], [DBGTEXTVERTICALSPACE] //GOTO A NEWLINE
ADD [GRAPHICSDATA00+1], 15
MOV [GRAPHICSDATA01+0],512 //WIDTH OF MEMORY VIEWER "WINDOW"
MOV EDX, [GRAPHICSDATA00+1] //EDX = Y
SUB EDX, 512 //EDX = (CURRENT Y OF GRAPHICSDATA00 - 512)
FABS EDX ,EDX //MAKE SURE ITS NOT NEGATIVE 
MOV [65476], 7 //SET LINE WIDTH
MOV [GRAPHICSDATA01+1],EDX //SET HEIGHT FOR MEMORY VIEWER "WINDOW"
DCOLOR GCOL_BLACK
DRECTWH GRAPHICSDATA00, GRAPHICSDATA01
DCOLOR GCOL_GREY
DORECTWH GRAPHICSDATA00, GRAPHICSDATA01

MOV [DEBUGWNDCOORDS], [GRAPHICSDATA00] //SAVE X1 FOR LATER (PLACEMENT POS X-AXIS)
MOV [DEBUGWNDCOORDS+1], [GRAPHICSDATA00+1] //SAVE Y1 FOR LATER (PLACEMENT POS Y-AXIS)
MOV [DEBUGWNDCOORDS+2], [GRAPHICSDATA01] //SAVE X2 FOR LATER (WIDTH)
MOV [DEBUGWNDCOORDS+3], [GRAPHICSDATA01+1] //SAVE Y2 FOR LATER (HEIGHT)

GRAPHICSDEBUG_PRINTMEMORY_000: //PRINT MEMORY ADDRESS AT BEGINNING OF  
//EAX = [DBGPRINTMEMORYOFFSET]     //EACH LINE FOR THE 1ST ADDRESSES IN EACH LINE
//EBX = WIDTH OF DBGPRINTMEMORYCOLUMNS
MOV ECX, [DBGVALUESPERCOLUMN]
DTEXTWIDTH EDX, DBGADDRMAXDIGITS
ADD [GRAPHICSDATA00+1], [DBGTEXTVERTICALSPACE] //GOTO A NEWLINE
MOV R0, [GRAPHICSDATA00] //SAVE X 
MOV R1, [GRAPHICSDATA00+1]//SAVE Y
MOV [GRAPHICSDATA03], R0 //SAVE CURRENT COORD. ITS NEEDED FOR PLACEING ALL OF THE VALUES
MOV [GRAPHICSDATA03+1], R1 

MOV R2, EAX //SAVE OFFSET
ADD R2, [DBGADDRMAXDIGITSNUM] //ADD DIGITS NUM SO ADDRESS DISPLAYS PROPERLY
DCOLOR GCOL_WHITE
GRAPHICSDEBUG_PRINTMEMORY_001: //PRINT THE ADDRESSES FOR THE 1ST NUMBER FOR EACH ROW

DWRITEI GRAPHICSDATA00,R2 //PRINT OFFSET

ADD [GRAPHICSDATA00], EDX //MOVE X OVER TO PLACE COLON
DWRITE GRAPHICSDATA00, DBGPRINTCOLON // PRINT COLON SO NUMBERS LOOK LIKE "23782: "
MOV R3, [GRAPHICSDATA03] //LOAD ORIGINAL X VALUE
MOV [GRAPHICSDATA00], R3 //RESTORE X VALUE (WHICH IN THIS CASE SHOULD ALWAYS BE ZERO)

ADD [GRAPHICSDATA00+1], [DBGTEXTVERTICALSPACE] //GOTO A NEWLINE
ADD R2, [DBGVALUESPERROW] //GOTO NEXT ADDRESS THAT NEEDS TO BE PRINTED
DEC ECX
CMP ECX, 0 //IF ALL VALUES IN THE COLUMN HAVE BEEN PRINTED...
JNLE GRAPHICSDEBUG_PRINTMEMORY_001
GRAPHICSDEBUG_PRINTMEMORY_01: //PREPARE TO PRINT MEMORY
// EAX = DBGPRINTMEMORYOFFSET
// EBX = WIDTH OF DBGPRINTMEMORYCOLUMNS
MOV ECX, [DBGVALUESPERROW]
//EDX = WIDTH OF DBGADDRMAXDIGITS
DTEXTWIDTH R0, DBGPRINTCOLON
ADD EDX, R0 //CORRECT X-AXIS OFFSET FOR 1 # IN ROW
ADD [GRAPHICSDATA00], EDX //OFFSET X POSITION
//XOR R1,R1 //MEM OFFSET (NOT NEEDED)
MOV R1, [DBGVALUESPERCOLUMN] //ROW COUNTER
DTEXTWIDTH R3, DBGNUMMAXDIGITS //FOR SPACING NUMBERS FROM EACHOTHER
MOV [GRAPHICSDATA00+1],[GRAPHICSDATA03+1] //SET THE Y POSITION TO THE TOP LEFT OF THE MEMORY VIEW WINDOW

GRAPHICSDEBUG_PRINTMEMORY_010: //ACTUALLY PRINT MEMORY
DWRITEI GRAPHICSDATA00, [EAX]
//DEND 
//DBEGIN
INC EAX
DEC ECX 
ADD [GRAPHICSDATA00], R3 //MOVE OVER TO PLACE NEXT NUMBER ON ROW
CMP ECX, 0 //IF ALL NUMBERS IN THE ROW HAVEN'T BEEN PLACED
JNLE GRAPHICSDEBUG_PRINTMEMORY_010 //REPEAT THE LOOP UNTIL ALL NUMBERS HAVE BEEN PLACED ON THAT ROW
GRAPHICSDEBUG_PRINTMEMORY_011: //SWITCH TO NEXT ROW
MOV [GRAPHICSDATA00], 0
ADD [GRAPHICSDATA00], EDX //OFFSET X POS
DEC R1
CMP R1, 0
JLE GRAPHICSDEBUG_PRINTMEMORY_02 //IF ALL OF THE ROWS HAVE BEEN PRINTED, GOTO CLEANUP
ADD [GRAPHICSDATA00+1], [DBGTEXTVERTICALSPACE] //GOTO A NEWLINE
MOV ECX, [DBGVALUESPERROW] //RESET VALUE FOR LOOP
JMP GRAPHICSDEBUG_PRINTMEMORY_010
GRAPHICSDEBUG_PRINTMEMORY_02: //CLEANUP
DCOLOR GCOL_GREY
MOV EAX, DEBUGWNDCOORDS //ADDR OF PLACEMENT POSITION VECTOR
LEA EBX, [DEBUGWNDCOORDS+2] //ADDR OF WIDTH AND HEIGHT OF FRAME
DORECTWH EAX, EBX //REDRAW FRAME FOR MEM VIEWER


DEND        //THIS BIT OF CODE IS SO THAT THE SCREEN UPDATES WHENEVER THE DEBUG FUNCTION
DBEGIN      //IS CALLED INSTEAD OF ONLY THE FIRST TIME ITS ENCOUNTERED.
POPA
RET
//-------------------------------------------//
